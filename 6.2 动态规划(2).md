
# 动态规划(2)

* 装箱问题

* 背包问题

* 完全背包

* 多重背包

* 二维费用背包问题

## 装箱问题

* 题目
> 有一个箱子容量为V（正整数，0＜＝V＜＝20000），同时有n个物品（0＜n＜＝30），每个物品有一个体积（正整数）。
  要求n个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。
  输入描述：一个整数v，表示箱子容量；一个整数n，表示有n个物品；接下来n个整数，分别表示这n 个物品的各自体积
  输出描述：一个整数，表示箱子剩余空间

* 输入
> 24 6  
> 8 3 12 7 9 7

* 输出
> 0

* 原理
> 状态转移方程 一:  
> 1. dp[i][j + data[i]] = 1            # 选择该箱子的状态  
> 2. dp[i][j] = 1                      # 不选择该箱子时的状态  
> 状态转移方程 二:  
> 1. dp[j]                             # 不选择该箱子时的状态  
> 2. dp[j-data[i]]+data[i]             # 选择该箱子的状态  

* 代码
```$xslt

    # 状态转移方程一的基本代码
    void code1{
         for (int i = 0; i <= size; i++) {
            dp[i][data[i]] = 1;
            for (int j = 0; j <= sum; j++) {
                if (dp[i - 1][j] == 1) {
                    dp[i][j + data[i]] = 1;
                    dp[i][j] = 1;
                }
            }
         }
    }

    # 状态转移方程二的基本代码
    void code2{
        for(int i=0;i<c;i++){
            cin>>data[i];
            for(int j=r;j>=data[i];j--){
                dp[j] = max( dp[j], dp[ j-data[i] ] + data[i] );
            }
        }	
    }

```

## 背包问题

* 题目

>有N件物品和一个容量为V的背包。第i件物品的体积是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。

* 输入
> N = 6  V = 12  
  费用c[i]，价值w[i]  
  5           10  
  3           7  
  2           4  
  4           3  
  5           17  
  4           8  

* 输出
> 
>
>

* 原理
> 状态转移方程  
> 1. 不放当前物品  dp[i][j] = dp[i-1][j]  
> 2. 放当前物品    dp[i][j] = dp[i-1][j-c[i]]+w[i]    
 

* 代码

```$xslt
    for (int i = 1 ; i <= n; i++ ){
        for (int j=m; j>=c[i]; j--)
            dp[j] = max(dp[j], dp[j-v[i]] + w[i]);
    }

```

## 完全背包

* 题目

> 有 N 种物品和一个容量为 V 的背包，每种物品都有无限件可用。放入第 i 种物品的费用是 Ci ，价值是 Wi 。求解：将哪些物品装入背包，可使这些物品的耗费的费用总和不超过背包容量，且价值总和最大

* 输入

> 略

* 输出

> 略


* 原理

> 状态转移方程
> 1. 不放当前物品 f[j]
> 2. 放当前物品 f[j-c[i]] + w[i]


* 代码
```c++
    for (int i = 1 ; i <= n; i++ ){
        for (int j=c[i]; j <= m; j++)
            dp[j] = max(dp[j], dp[j - c[i]] + w[i]);
    }
```


## 多重背包

* 题目
> 在《Harry Potter and the Deathly Hallows》中，Harry Potter他们一起逃亡，现 在有许多的东西要放到赫敏的包里面，但是包的大小有限，所以我们只能够在里面放入非常 重要的物品，现在给出该种物品的数量、体积、价值的数值，希望你能够算出能使背包的价 值最大的组合方式，并且输出这个数值，赫敏会非常地感谢你。

* 输入

> 第一行有 2 个整数，物品种数 n 和背包装载体积 v。   
  2行到 i+1 行每行 3 个整数，为第 i 种物品的数量 m、体积 w、价值 s。  
  对于 30%的数据 1<=v<=500，1<=n<=2000，1<=m<=10，1<=w<=20，1<=s<=100  
  对于 100%的数据 1<=v<=500，1<=n<=2000，1<=m<=5000，1<=w<=20，1<=s<=100  

* 输出

> 包含一个整数，即为能拿到的最大的物品价值总和。

* 原理

> 略

* 代码
```c++
    for(int i=0;i<n;i++){
        cin>>m[i]>>w[i]>>s[i]; // m 数量; w 体积； s 价值
    }
     
    for(int i=0;i<n;i++)
        for(int j=0;j<m[i];j++)
            for(int k=v;k>=w[i];k--)    // v 总体积
                dp[k] = max(dp[k], dp[k-w[i]]+s[i]);
```

* 二进制优化
```c++
#include<bits/stdc++.h>

using namespace std;

int n, v;
int m[505], w[505], s[505];
int dp[505];

int main() {

    cin >> n >> v;
    for (int i = 0; i < n; ++i) {
        cin >> m[i] >> w[i] >> s[i];
    }

    for (int i = 0; i < n; ++i) {
        int k = 1;
        int t = m[i];
        while (k < t) {
            for (int j = v; j >= w[i] * k; --j) {
                dp[j] = max(dp[j], dp[j - w[i] * k] + s[i] * k);
            }
            t -= k;
            k *= 2;
        }
        for (int j = v; j >= w[i] * t; --j) {
            dp[j] = max(dp[j], dp[j - w[i] * t] + s[i] * t);
        }
    }
    cout<<dp[v]<<endl;

}
 
```

## 二维费用背包问题

>对于每件物品，具有两种不同的费用;
 选择这件物品必须同时付出这两种代价;
 对于每种代价都有一个可付出的最大值（背包容量）.


* 输入

> 略

* 输出

> 略

* 原理

> 略

* 代码
```c++
    cin>>v>>g>>n;   // v 最大重量; g 最大体积; n件物品
    for(int i=0;i<n;i++){
        cin>>ti[i]>>vi[i]>>gi[i];   // ti 价值; vi 重量; gi 体积 
    }
     
    for(int i=0;i<n;i++){
        for(int j = v; j>=vi[i];j--){
            for(int k = g; k>=gi[i];k--){
                dp[j][k] = max(dp[j][k], dp[j-vi[i]][k-gi[i]]+ti[i]);
            }
        }
    }
    cout<<dp[v][g]<<endl;
```
