
# 动态规划(2)

* 装箱问题

* 背包问题

* 完全背包

* 多重背包

* 二维费用背包问题

## 装箱问题

* 题目
> 有一个箱子容量为V（正整数，0＜＝V＜＝20000），同时有n个物品（0＜n＜＝30），每个物品有一个体积（正整数）。
  要求n个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。
  输入描述：一个整数v，表示箱子容量；一个整数n，表示有n个物品；接下来n个整数，分别表示这n 个物品的各自体积
  输出描述：一个整数，表示箱子剩余空间

* 输入
> 24 6  
> 8 3 12 7 9 7

* 输出
> 0

* 原理
> 状态转移方程 一:  
> 1. dp[i][j + data[i]] = 1            # 选择该箱子的状态  
> 2. dp[i][j] = 1                      # 不选择该箱子时的状态  
> 状态转移方程 二:  
> 1. dp[j]                             # 不选择该箱子时的状态  
> 2. dp[j-data[i]]+data[i]             # 选择该箱子的状态  

* 代码
```$xslt

    # 状态转移方程一的基本代码
    void code1{
         for (int i = 0; i <= size; i++) {
            dp[i][data[i]] = 1;
            for (int j = 0; j <= sum; j++) {
                if (dp[i - 1][j] == 1) {
                    dp[i][j + data[i]] = 1;
                    dp[i][j] = 1;
                }
            }
         }
    }

    # 状态转移方程二的基本代码
    void code2{
        for(int i=0;i<c;i++){
            cin>>data[i];
            for(int j=r;j>=data[i];j--){
                dp[j] = max( dp[j], dp[ j-data[i] ] + data[i] );
            }
        }	
    }

```

## 背包问题

* 题目

>有N件物品和一个容量为V的背包。第i件物品的体积是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。

* 输入
> N = 6  V = 12  
  费用c[i]，价值w[i]  
  5           10  
  3           7  
  2           4  
  4           3  
  5           17  
  4           8  

* 输出
> 
>
>

* 原理
> 状态转移方程  
> 1. 不放当前物品  dp[i][j] = dp[i-1][j]  
> 2. 放当前物品    dp[i][j] = dp[i-1][j-c[i]]+w[i]    
 

* 代码

```$xslt
    for (int i = 1 ; i <= n; i++ ){
        for (int j=m; j>=c[i]; j--)
            dp[j] = max(dp[j], dp[j-v[i]] + w[i]);
    }

```

## 完全背包

* 题目

> 有 N 种物品和一个容量为 V 的背包，每种物品都有无限件可用。放入第 i 种物品的费用是 Ci ，价值是 Wi 。求解：将哪些物品装入背包，可使这些物品的耗费的费用总和不超过背包容量，且价值总和最大

* 输入

> 略

* 输出

> 略


* 原理

> 状态转移方程
> 1. 不放当前物品 f[j]
> 2. 放当前物品 f[j-c[i]] + w[i]


* 代码
```c++
    for (int i = 1 ; i <= n; i++ ){
        for (int j=c[i]; j <= m; j++)
            dp[j] = max(dp[j], dp[j - c[i]] + w[i]);
    }
```


## 多重背包

* 题目
> 有N种物品和一个容量为V的背包.第i种物品最多有n[i]件可用,每件费用是w[i],价值是c[i].求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大.

* 输入

> 略

* 输出

> 略

* 原理

> 略

* 代码
```c++
    for(int i=0;i<n;i++){
        cin>>m[i]>>w[i]>>s[i]; // m 数量; w 体积； s 价值
    }
     
    for(int i=0;i<n;i++)
        for(int j=0;j<m[i];j++)
            for(int k=v;k>=w[i];k--)    // v 总体积
                dp[k] = max(dp[k], dp[k-w[i]]+s[i]);
```

* 二进制优化
```c++
#include<bits/stdc++.h> 
 
using namespace std;
 
struct node{
    int w,s;    // w 体积; s价值
};
int n,v,p,ind=0;
int dp[30000];
vector<node> data;
 
int main(){
 
    cin>>n>>v;
    for(int i=0;i<n;i++){
        int m,w,s;
        p=1;    // 二进制标志
        scanf("%d %d %d",&m,&w,&s); // m 数量; w 体积； s 价值
        while(m-p>0){
            m-=p;
            data.push_back({p*w, p*s});
            p*=2;
        }
        if(m){
            data.push_back({w*m, s*m});
        }
         
    }
    for(int i=0;i<=v;i++) dp[i]=0;
    for(int i=0;i<data.size();i++)
        for(int j=v;j>=data[i].w;j--){
            dp[j] = max(dp[j], dp[j-data[i].w]+data[i].s);
        }
     
    cout<<dp[v]<<endl;
    return 0; 
}
 
```

## 二维费用背包问题

>对于每件物品，具有两种不同的费用;
 选择这件物品必须同时付出这两种代价;
 对于每种代价都有一个可付出的最大值（背包容量）.


* 输入

> 略

* 输出

> 略

* 原理

> 略

* 代码
```c++
    cin>>v>>g>>n;   // v 最大重量; g 最大体积; n件物品
    for(int i=0;i<n;i++){
        cin>>ti[i]>>vi[i]>>gi[i];   // ti 价值; vi 重量; gi 体积 
    }
     
    for(int i=0;i<n;i++){
        for(int j = v; j>=vi[i];j--){
            for(int k = g; k>=gi[i];k--){
                dp[j][k] = max(dp[j][k], dp[j-vi[i]][k-gi[i]]+ti[i]);
            }
        }
    }
    cout<<dp[v][g]<<endl;
```
