
# 二叉树(三种遍历的转换)


* 根据后序遍历、中序遍历求先序遍历
* 根据先序遍历、中序遍历求后序遍历
* 根据先序遍历、后序遍历求中序遍历


## 根据后序遍历、中序遍历求先序遍历

```c++
struct tree {
    int data;
    tree *right, *left;
};

int n;
int postorder[35], inorder[35], visit[35];
tree *res;


int main(){
    cin >> n;
    for (int i = 0; i < n; ++i) {
        cin >> inorder[i];
    }
    for (int i = 0; i < n; ++i) {
        cin >> postorder[i];
    }
    res = create(0, n - 1, 0, n - 1);
}


tree *create(int i1, int i2, int p1, int p2) {
    if (i1 > i2 || p1 > p2)return NULL;
    tree *root = new tree();
    root->data = postorder[p2];
    int k;
    for (int i = i1; i <= i2; i++) {
        if (inorder[i] == root->data) {
            k = i;
            break;
        }
    }
    root->left = create(i1, k - 1, p1, p1 + k - 1 - i1);
    root->right = create(k + 1, i2, p2 - 1 - (i2 - k - 1), p2 - 1);
    return root;
}
```

## 根据先序遍历、中序遍历求后序遍历

```c++
struct node {
    int data;
    node *lchild;
    node *rchild;
};

void post_dfs(node *root);

int pre[maxn], in[maxn], post[maxn];
int n;

node *create(int preL, int preR, int inL, int inR) {
    if (preL > preR) {
        return NULL;
    }

    node *root = new node;
    root->data = pre[preL];
    int k;
    for (k = inL; k <= inR; ++k) {
        if (in[k] == pre[preL])
            break;

    }
    int numLeft = k - inL;
    root->lchild = create(preL + 1, preL + numLeft, inL, k - 1);
    root->rchild = create(preL + numLeft + 1, preR, k + 1, inR);
    return root;
}

int main(){
    cin >> n;
    for (int i = 0; i < n; ++i) {
        cin >> inorder[i];
    }
    for (int i = 0; i < n; ++i) {
        cin >> postorder[i];
    }
    node *root = create(0, n - 1, 0, n - 1);

    post_dfs(root); // dfs将root数里的数据放到数组里，容易遍历
    for (int i = 0; i < n; ++i) {
        cout << post[i];
        if (i != n - 1) {
            cout << " ";
        }
    }
}

int post_index = 0;

void post_dfs(node *root) {
    if (root == NULL) return;
    post_dfs(root->lchild);
    post_dfs(root->rchild);
    post[post_index++] = root->data;

}

```

## 根据先序遍历、后序遍历求中序遍历

```c++

vector<int> in, pre, post;
bool unique = true;
void getIn(int preLeft, int preRight, int postLeft, int postRight) {
    if(preLeft == preRight) {
        in.push_back(pre[preLeft]);
        return;
    }
    if (pre[preLeft] == post[postRight]) {
        int i = preLeft + 1;
        while (i <= preRight && pre[i] != post[postRight-1]) i++;
        if (i - preLeft > 1)
            getIn(preLeft + 1, i - 1, postLeft, postLeft + (i - preLeft - 1) - 1);
        else
            unique = false;
        in.push_back(post[postRight]);
        getIn(i, preRight, postLeft + (i - preLeft - 1), postRight - 1);
    }
}


int main(){
    cin >> n;
    for (int i = 0; i < n; ++i) {
        cin >> inorder[i];
    }
    for (int i = 0; i < n; ++i) {
        cin >> postorder[i];
    }
    node *root = create(0, n - 1, 0, n - 1);

    for (int i = 0; i < n; i++)
        scanf("%d", &pre[i]);
    for (int i = 0; i < n; i++)
        scanf("%d", &post[i]);

    getIn(0, n-1, 0, n-1);

    for (int i = 1; i < in.size(); i++)
        printf(" %d", in[i]);
}

```